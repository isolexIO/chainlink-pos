
import { useState, useEffect, useMemo, useCallback } from "react";
import { Product } from "@/entities/Product";
import { OnlineOrder } from "@/entities/OnlineOrder";
import { User } from "@/entities/User"; // Import User
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription, // Added DialogDescription
  DialogFooter // Added DialogFooter
} from "@/components/ui/dialog";
import { Label } from "@/components/ui/label"; // Added Label import for payment form
import {
  ShoppingCart,
  Plus,
  Minus,
  Heart,
  Car,
  Store,
  UtensilsCrossed,
  Receipt,
  CreditCard, // Added CreditCard
  Bitcoin,    // Added Bitcoin
  CheckCircle, // Added CheckCircle for confirmation
  QrCode // Added QrCode for Solana Pay
} from "lucide-react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"; // Corrected Tabs import path
import ModifierDialog from "../components/online-menu/ModifierDialog"; // Import the ModifierDialog component
import ProductGrid from '../components/pos/ProductGrid'; // Import the ProductGrid component

// Placeholder for SolanaPayScreen component. In a real app, this would be a separate file
// integrating with Solana Pay libraries (e.g., @solana/pay) to generate actual QR codes
// and monitor blockchain for payment confirmation.
const SolanaPayScreen = ({ order, settings, onPaymentComplete, onPaymentFailed }) => {
  const [qrCodeUrl, setQrCodeUrl] = useState('');
  const [loadingQr, setLoadingQr] = useState(false);
  const [error, setError] = useState('');
  const [simulatedSignature, setSimulatedSignature] = useState(''); // To simulate a completed signature
  const [isSimulatingPayment, setIsSimulatingPayment] = useState(false);

  useEffect(() => {
    if (order && settings?.solana_pay?.enabled && !simulatedSignature) {
      setLoadingQr(true);
      setError('');
      // Simulate API call to generate Solana Pay link
      setTimeout(() => {
        try {
          const amount = order.total;
          const recipient = settings.solana_pay.wallet_address || 'YOUR_MERCHANT_SOLANA_ADDRESS';
          const label = settings.solana_pay.label || 'Online Order';
          const message = `Payment for Order #${order.order_number}`;
          const reference = order.id; // Or a unique transaction ID
          
          // Construct a simplified Solana Pay URL. Real Solana Pay URLs are more complex
          // and often generated by a backend service or a dedicated library.
          const url = `solana:${recipient}?amount=${amount}&label=${encodeURIComponent(label)}&message=${encodeURIComponent(message)}&reference=${reference}`;
          
          setQrCodeUrl(url);
        } catch (e) {
          console.error("Error generating Solana Pay URL:", e);
          setError("Failed to generate Solana Pay QR code.");
        } finally {
          setLoadingQr(false);
        }
      }, 1000);
    }
  }, [order, settings, simulatedSignature]);

  const handleSimulatePayment = () => {
    setIsSimulatingPayment(true);
    setTimeout(() => {
      // Simulate a successful payment and a transaction signature
      const signature = `simulated_solana_tx_${Date.now()}`;
      setSimulatedSignature(signature);
      onPaymentComplete(signature);
      setIsSimulatingPayment(false);
    }, 2000);
  };

  if (!order || !settings?.solana_pay?.enabled) {
    return (
      <div className="text-center text-red-500 dark:text-red-400">
        Solana Pay is not available or misconfigured.
      </div>
    );
  }

  return (
    <div className="text-center">
      <h3 className="text-xl font-semibold mb-4">Pay with Solana</h3>
      <p className="text-lg font-bold mb-2">Amount: ${order.total.toFixed(2)}</p>
      {loadingQr && <p className="text-gray-500 dark:text-gray-400">Generating QR code...</p>}
      {error && <p className="text-red-500 dark:text-red-400">{error}</p>}
      {qrCodeUrl && !simulatedSignature && (
        <div className="flex flex-col items-center">
          <p className="text-sm text-gray-500 dark:text-gray-400 mb-4">Scan this QR code with your Solana wallet</p>
          <div className="bg-gray-100 dark:bg-gray-700 p-4 rounded-md mb-4 break-all max-w-full text-gray-800 dark:text-gray-200">
            {/* In a real app, this would be a QR code image (e.g., <img src={qrCodeImage}/>) */}
            <QrCode className="w-24 h-24 mx-auto mb-2 text-gray-600 dark:text-gray-300" />
            <p className="font-mono text-xs">{qrCodeUrl}</p>
            <Button variant="link" className="mt-2 text-blue-500 dark:text-blue-400 text-sm" onClick={() => navigator.clipboard.writeText(qrCodeUrl)}>
              (Click to copy URL)
            </Button>
          </div>
          <Button onClick={handleSimulatePayment} disabled={isSimulatingPayment} className="w-full">
            {isSimulatingPayment ? 'Processing...' : 'Simulate Payment Completed'}
          </Button>
          <p className="text-xs text-gray-400 mt-2">
            (In a real app, payment confirmation would be automatic via webhook/polling)
          </p>
        </div>
      )}
      {simulatedSignature && (
        <div className="text-green-500 dark:text-green-400 flex flex-col items-center">
          <CheckCircle className="w-12 h-12 mb-2" />
          <p className="font-semibold">Payment Confirmed!</p>
          <p className="text-xs text-gray-500 dark:text-gray-400 break-all mt-1">Tx: {simulatedSignature}</p>
        </div>
      )}
    </div>
  );
};


const ProductCard = ({ product, onAddToCart, onToggleFavorite, isFavorite }) => {
  return (
    <Card className="overflow-hidden hover:shadow-lg transition-shadow group dark:bg-gray-900 dark:border-gray-700 dark:text-white">
      <div className="aspect-video bg-gray-200 dark:bg-gray-700 relative cursor-pointer" onClick={() => onAddToCart(product)}>
        <img
          src={product.image_url || `https://via.placeholder.com/400x300/F0F0F0/AAAAAA?text=${product.name}`}
          alt={product.name}
          className="w-full h-full object-cover"
        />
        <Button
          variant="ghost"
          size="icon"
          className="absolute top-2 right-2 bg-white/70 hover:bg-white rounded-full dark:bg-gray-800/70 dark:hover:bg-gray-800"
          onClick={(e) => { e.stopPropagation(); onToggleFavorite(product.id); }}
        >
          <Heart className={`w-5 h-5 transition-all ${isFavorite ? 'text-red-500 fill-red-500' : 'text-gray-600 dark:text-gray-400'}`} />
        </Button>
      </div>
      <CardContent className="p-4">
        <div className="flex justify-between items-start mb-2">
          <h3 className="font-semibold text-lg">{product.name}</h3>
          <span className="font-bold text-lg text-green-600">
            ${product.price.toFixed(2)}
          </span>
        </div>
        {product.description && (
          <p className="text-gray-600 text-sm mb-3 line-clamp-2 dark:text-gray-400">
            {product.description}
          </p>
        )}
        <div className="flex justify-between items-center">
          <Badge variant="secondary" className="capitalize dark:bg-gray-700 dark:text-gray-200">
            {product.category}
          </Badge>
          <Button
            onClick={() => onAddToCart(product)}
            size="sm"
            className="flex items-center gap-1"
          >
            <Plus className="w-4 h-4" />
            Add
          </Button>
        </div>
      </CardContent>
    </Card>
  )
}

export default function OnlineMenuPage() {
  const [products, setProducts] = useState([]);
  const [cart, setCart] = useState([]);
  const [selectedCategory, setSelectedCategory] = useState("all");
  const [showCart, setShowCart] = useState(false);
  const [showCheckout, setShowCheckout] = useState(false);
  const [checkoutStep, setCheckoutStep] = useState('details'); // details, payment, confirmation
  const [showAccount, setShowAccount] = useState(false);
  const [customerInfo, setCustomerInfo] = useState({
    name: "",
    email: "",
    phone: "",
    fulfillment_type: "pickup",
    delivery_address: "",
    special_instructions: "",
    requested_time: ""
  });
  const [loading, setLoading] = useState(true);
  const [currentUser, setCurrentUser] = useState(null);
  const [pastOrders, setPastOrders] = useState([]);
  const [favoriteProducts, setFavoriteProducts] = useState([]);
  const [businessSettings, setBusinessSettings] = useState(null); // Added state for business settings
  const [selectedProductForModifiers, setSelectedProductForModifiers] = useState(null);
  // New states for Solana Pay integration
  const [paymentMethod, setPaymentMethod] = useState('card'); // 'card', 'cash', 'solana_pay'
  const [currentOrder, setCurrentOrder] = useState(null); // Stores the order after initial creation
  const [showSolanaPayModal, setShowSolanaPayModal] = useState(false); // Controls Solana Pay modal visibility

  const loadUserData = useCallback(async (user) => {
    try {
      // Fetch past orders
      const userOrders = await OnlineOrder.filter({ created_by: user.email }, "-created_date", 20);
      setPastOrders(userOrders);

      // Fetch favorite products
      if(user.favorite_product_ids && user.favorite_product_ids.length > 0) {
        const favs = await Product.filter({ id: { "$in": user.favorite_product_ids } });
        setFavoriteProducts(favs);
      } else {
        setFavoriteProducts([]); // Clear if no favorites
      }
    } catch (error) {
      console.error("Error loading user data:", error);
    }
  }, []);

  const loadInitialData = useCallback(async () => {
    try {
      setLoading(true);
      const productList = await Product.list();
      setProducts(productList.filter(p => p.is_active));

      const userData = await User.me(); // Fetch current user data
      setCurrentUser(userData);

      // In a real app, public business settings would be fetched from a separate public entity.
      // Here, we'll simulate it if the logged-in user has settings.
      if (userData?.pos_settings) {
        setBusinessSettings(userData.pos_settings);
      } else {
        // Fallback or default settings if no user or no pos_settings
        // This is a placeholder; in a real app, these would come from a public API endpoint
        setBusinessSettings({
          acceptCrypto: true, // Assuming crypto is generally enabled
          online_ordering: { // Added online_ordering settings
            allow_cash_payment: true, // Default to true for cash payment
          },
          blockchain: {
            btc_address: "bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh",
            eth_address: "0x742d35Cc6634C0532925a3b844Bc454e4438f444",
            sol_address: "Af1rWn1mXfG7X21wV6Zf2d5Jc4b5h6j7k8l9m0n1o2p3"
          },
          solana_pay: { // Added Solana Pay settings
            enabled: true,
            wallet_address: "B1iGMjU5T1hC2f4fP2M7w2vC8xY2bA7d9p5H4j6k3L", // Placeholder Solana wallet address
            label: "Online Order Payment",
            currency: "SOL"
          }
        });
      }

      if(userData){
        setCustomerInfo(prev => ({ ...prev, name: userData.full_name, email: userData.email }));
        loadUserData(userData); // Load user specific data like orders and favorites
      }

    } catch (error) {
      console.error("Error loading initial data:", error);
      // It's a public page, so we don't need to throw an error if user is not logged in.
    } finally {
      setLoading(false);
    }
  }, [loadUserData]);

  useEffect(() => {
    loadInitialData();
  }, [loadInitialData]);

  const handleToggleFavorite = useCallback(async (productId) => {
    if(!currentUser) {
      alert("Please log in to save favorites!");
      return;
    }

    const currentFavorites = currentUser.favorite_product_ids || [];
    let newFavorites;

    if(currentFavorites.includes(productId)){
      newFavorites = currentFavorites.filter(id => id !== productId);
    } else {
      newFavorites = [...currentFavorites, productId];
    }

    try {
      await User.updateMyUserData({ favorite_product_ids: newFavorites });
      const updatedUser = await User.me(); // Re-fetch user data to get updated favorites
      setCurrentUser(updatedUser);
      loadUserData(updatedUser); // Reload user-specific data
    } catch(error) {
      console.error("Error updating favorites", error);
    }
  }, [currentUser, loadUserData]);

  const addToCart = (product, modifiers = []) => {
    // Stringify modifiers to ensure deep comparison for uniqueness
    const existingItemIndex = cart.findIndex(
      item => item.id === product.id &&
      JSON.stringify(item.modifiers) === JSON.stringify(modifiers)
    );
    const modifierTotal = modifiers.reduce((sum, mod) => sum + mod.price_adjustment, 0);

    if (existingItemIndex > -1) {
      const newCart = [...cart];
      newCart[existingItemIndex].quantity += 1;
      newCart[existingItemIndex].item_total =
        (product.price + modifierTotal) *
        newCart[existingItemIndex].quantity;
      setCart(newCart);
    } else {
      setCart([...cart, {
        ...product,
        quantity: 1,
        modifiers,
        item_total: product.price + modifierTotal
      }]);
    }
    setSelectedProductForModifiers(null); // Close modifier dialog after adding
  };

  const updateCartQuantity = (index, quantity) => {
    if (quantity === 0) {
      setCart(cart.filter((_, i) => i !== index));
      return;
    }

    const newCart = [...cart];
    const item = newCart[index];
    const modifierTotal = item.modifiers?.reduce((sum, m) => sum + m.price_adjustment, 0) || 0;
    newCart[index].quantity = quantity;
    newCart[index].item_total = (item.price + modifierTotal) * quantity;
    setCart(newCart);
  };

  const calculateTotals = () => {
    const subtotal = cart.reduce((sum, item) => sum + item.item_total, 0);
    const deliveryFee = customerInfo.fulfillment_type === "delivery" ? 4.99 : 0;
    const taxRate = 0.08;
    const taxAmount = (subtotal + deliveryFee) * taxRate;
    const total = subtotal + deliveryFee + taxAmount;

    return {
      subtotal: subtotal.toFixed(2),
      deliveryFee: deliveryFee.toFixed(2),
      taxAmount: taxAmount.toFixed(2),
      total: total.toFixed(2)
    };
  };

  // Helper function to reset all order-related states
  const resetOrderState = useCallback(() => {
    setCart([]);
    setCustomerInfo({
      name: currentUser ? currentUser.full_name : "",
      email: currentUser ? currentUser.email : "",
      phone: "",
      fulfillment_type: "pickup",
      delivery_address: "",
      special_instructions: "",
      requested_time: ""
    });
    setShowCheckout(false); // Close the checkout modal
    setCheckoutStep('details'); // Reset checkout step for next order
    setPaymentMethod('card'); // Reset payment method to default
    setCurrentOrder(null);
    setShowSolanaPayModal(false); // Updated: Use showSolanaPayModal
  }, [currentUser]);

  // Function to handle card/crypto payment submission (after order is created)
  const processCardCryptoPayment = async (paymentDetails) => {
    setLoading(true);
    try {
      if (!currentOrder) {
        console.error("No current order found for payment processing!");
        alert("Error: No order to process. Please restart checkout.");
        setCheckoutStep('details');
        setLoading(false);
        return;
      }

      const finalOrderData = {
        status: "confirmed", // Set status to confirmed after successful payment
        payment_status: "paid", // Set payment status to paid
        payment_method: paymentDetails.method // Add payment method
      };

      await OnlineOrder.update(currentOrder.id, finalOrderData);

      setCheckoutStep('confirmation'); // Show confirmation step immediately

      // Reset cart and customer info after a delay
      setTimeout(resetOrderState, 5000); // Redirect after 5 seconds

      if(currentUser) {
        loadUserData(currentUser); // Refresh user data after order
      }
    } catch (error) {
      console.error("Error processing payment:", error);
      alert("Error processing payment. Please try again.");
      setCheckoutStep('payment'); // Stay on payment step if failed
    } finally {
      setLoading(false);
    }
  };

  // New function to initiate the order creation and direct to the appropriate payment flow
  const initiateOrderProcess = async () => {
    if (cart.length === 0) {
      alert('Your cart is empty');
      return;
    }

    // Validation based on existing customerInfo structure
    if (!customerInfo.name || !customerInfo.phone) {
      alert('Please enter your name and phone number');
      return;
    }
    if (customerInfo.fulfillment_type === 'delivery' && !customerInfo.delivery_address) {
      alert('Please enter a delivery address');
      return;
    }

    setLoading(true);

    try {
      const totals = calculateTotals();
      const orderNumber = `ON-${Date.now()}`;

      const orderData = {
        order_number: orderNumber,
        customer_name: customerInfo.name,
        customer_email: customerInfo.email || '',
        customer_phone: customerInfo.phone,
        items: cart.map(item => ({
          product_id: item.id,
          product_name: item.name,
          quantity: item.quantity,
          unit_price: item.price,
          modifiers: item.modifiers || [],
          item_total: item.item_total // This already includes modifier costs
        })),
        subtotal: parseFloat(totals.subtotal),
        tax_amount: parseFloat(totals.taxAmount),
        delivery_fee: parseFloat(totals.deliveryFee),
        total: parseFloat(totals.total),
        fulfillment_type: customerInfo.fulfillment_type,
        delivery_address: customerInfo.fulfillment_type === 'delivery' ? customerInfo.delivery_address : null,
        special_instructions: customerInfo.special_instructions || null,
        requested_time: customerInfo.requested_time || null,
        status: "pending", // Always pending initially until payment is confirmed
        payment_status: "unpaid", // Initially unpaid
        payment_method: paymentMethod // Store selected method
      };

      const createdOrder = await OnlineOrder.create(orderData);
      setCurrentOrder(createdOrder);

      if (paymentMethod === 'solana_pay') {
        setShowSolanaPayModal(true); // Updated: Use showSolanaPayModal
      } else if (paymentMethod === 'cash') {
        // For cash, mark as confirmed and paid by cash immediately
        await OnlineOrder.update(createdOrder.id, {
          status: 'confirmed',
          payment_status: 'paid',
          payment_method: 'cash'
        });
        setCheckoutStep('confirmation');
        setTimeout(resetOrderState, 5000);
        if(currentUser) { loadUserData(currentUser); }

      } else { // 'card' or other methods requiring a payment form (like existing crypto tab)
        setCheckoutStep('payment'); // Proceed to the payment form (card, crypto addresses)
      }

    } catch (error) {
      console.error('Error initiating order process:', error);
      alert('Failed to initiate order. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleSolanaPaymentComplete = async (signature) => {
    setLoading(true);
    try {
      if (!currentOrder) {
        console.error('No current order to update after Solana payment.');
        alert('Payment confirmed, but no order found to update. Please contact support.');
        setShowSolanaPayModal(false); // Updated: Use showSolanaPayModal
        setCheckoutStep('details');
        return;
      }
      await OnlineOrder.update(currentOrder.id, {
        status: 'confirmed',
        payment_status: 'paid',
        payment_details: {
          signature: signature,
          confirmed_at: new Date().toISOString()
        }
      });

      setCheckoutStep('confirmation'); // Show confirmation
      
      setTimeout(resetOrderState, 5000); // Clear state after delay
      if(currentUser) { loadUserData(currentUser); }

    } catch (error) {
      console.error('Error updating order after Solana payment:', error);
      alert('Solana Payment confirmed, but failed to update order status. Please contact support.');
      // Keep showSolanaPayModal open or transition to a specific error view if needed
    } finally {
      setLoading(false);
    }
  };


  const filteredProducts = useMemo(() => (products || []).filter(product =>
    selectedCategory === "all" || product.category === selectedCategory
  ), [products, selectedCategory]);

  const categories = useMemo(() => ["all", ...new Set((products || []).map(p => p?.category).filter(Boolean))], [products]);
  const totals = calculateTotals();

  if (loading && products.length === 0) { // Only show full-screen loader on initial load with no products
    return (
      <div className="min-h-screen bg-gray-50 dark:bg-gray-800 flex items-center justify-center">
        <div className="text-center">
          <div className="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
          <p className="text-gray-700 dark:text-gray-300">Loading menu...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-800">
      {/* Header */}
      <header className="bg-white dark:bg-gray-900 shadow-sm sticky top-0 z-50">
        <div className="max-w-7xl mx-auto px-4 py-4">
          <div className="flex justify-between items-center">
            <div>
              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Online Ordering</h1>
              <p className="text-gray-500 dark:text-gray-400">Order ahead for pickup or delivery</p>
            </div>
            <div className="flex items-center gap-4">
              {currentUser && (
                <Button variant="outline" onClick={() => setShowAccount(true)} className="dark:border-gray-700 dark:hover:bg-gray-700 dark:text-white">My Account</Button>
              )}
              <Button
                onClick={() => setShowCart(true)}
                className="relative"
                disabled={cart.length === 0}
              >
                <ShoppingCart className="w-5 h-5 mr-2" />
                Cart ({cart.length})
                {cart.length > 0 && (
                  <Badge className="absolute -top-2 -right-2 bg-red-500">
                    {cart.reduce((sum, item) => sum + item.quantity, 0)}
                  </Badge>
                )}
              </Button>
            </div>
          </div>
        </div>
      </header>

      <div className="max-w-7xl mx-auto px-4 py-8">
        {/* Category Filter */}
        <div className="mb-8">
          <div className="flex gap-2 overflow-x-auto pb-2">
            {categories.map(category => (
              <Button
                key={category}
                variant={selectedCategory === category ? "default" : "outline"}
                onClick={() => setSelectedCategory(category)}
                className="shrink-0 capitalize dark:border-gray-700 dark:hover:bg-gray-700 dark:text-white dark:bg-gray-900 dark:data-[state=active]:bg-blue-600"
              >
                {category === "all" ? "All Items" : category}
              </Button>
            ))}
          </div>
        </div>

        {/* Menu Items */}
        <ProductGrid
          products={filteredProducts}
          onAddToCart={(product, modifiersFromGrid) => {
            if (modifiersFromGrid && modifiersFromGrid.length > 0) {
              // ProductGrid already handled modifier selection and passed them
              addToCart(product, modifiersFromGrid);
            } else {
              // ProductGrid did not pass modifiers; check if the product itself has modifiers
              if (product.modifiers && product.modifiers.length > 0) {
                 // Product requires modifiers, open the ModifierDialog
                 setSelectedProductForModifiers(product);
              } else {
                 // Product has no modifiers, add directly to cart
                 addToCart(product);
              }
            }
          }}
          posMode="quick_service"
          isMobile={false}
          showImages={true}
          onToggleFavorite={handleToggleFavorite}
          isFavorite={(productId) => currentUser?.favorite_product_ids?.includes(productId)}
        />
      </div>

      {selectedProductForModifiers && (
        <ModifierDialog
          product={selectedProductForModifiers}
          onAddToCart={addToCart}
          onCancel={() => setSelectedProductForModifiers(null)}
        />
      )}

      {/* Cart Modal */}
      <Dialog open={showCart} onOpenChange={setShowCart}>
        <DialogContent className="sm:max-w-2xl max-h-[90vh] overflow-y-auto dark:bg-gray-800 dark:text-white">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <ShoppingCart className="w-5 h-5" />
              Your Order ({cart.length} items)
            </DialogTitle>
          </DialogHeader>

          {cart.length === 0 ? (
            <div className="text-center py-8">
              <ShoppingCart className="w-16 h-16 mx-auto text-gray-300 dark:text-gray-600 mb-4" />
              <p className="text-gray-500 dark:text-gray-400">Your cart is empty</p>
            </div>
          ) : (
            <div className="space-y-6">
              {/* Cart Items */}
              <div className="space-y-4">
                {(cart || []).map((item, index) => (
                  <div key={index} className="flex items-center gap-4 p-4 border rounded-lg dark:border-gray-700">
                    <div className="flex-1">
                      <h4 className="font-medium">{item?.name || 'Item'}</h4>
                      <p className="text-sm text-gray-500 dark:text-gray-400">${(item?.price || 0).toFixed(2)} each</p>
                      
                      {item?.modifiers && Array.isArray(item.modifiers) && item.modifiers.length > 0 && (
                        <div className="text-xs text-gray-600 dark:text-gray-300 mt-1">
                          + {(item.modifiers || []).map(mod => `${mod?.name || ''} ($${(mod?.price_adjustment || 0).toFixed(2)})`).filter(Boolean).join(", ")}
                        </div>
                      )}
                    </div>
                    <div className="flex items-center gap-2">
                      <Button
                        variant="outline"
                        size="icon"
                        onClick={() => updateCartQuantity(index, item.quantity - 1)}
                        className="h-8 w-8 dark:border-gray-700 dark:hover:bg-gray-700 dark:text-white"
                      >
                        <Minus className="w-3 h-3" />
                      </Button>
                      <span className="w-8 text-center">{item.quantity}</span>
                      <Button
                        variant="outline"
                        size="icon"
                        onClick={() => updateCartQuantity(index, item.quantity + 1)}
                        className="h-8 w-8 dark:border-gray-700 dark:hover:bg-gray-700 dark:text-white"
                      >
                        <Plus className="w-3 h-3" />
                      </Button>
                    </div>
                    <div className="font-medium">${item.item_total.toFixed(2)}</div>
                  </div>
                ))}
              </div>

              {/* Order Summary */}
              <div className="border-t pt-4 dark:border-gray-700">
                <div className="space-y-2 text-sm">
                  <div className="flex justify-between">
                    <span>Subtotal:</span>
                    <span>${totals.subtotal}</span>
                  </div>
                  {parseFloat(totals.deliveryFee) > 0 && (
                    <div className="flex justify-between">
                      <span>Delivery Fee:</span>
                      <span>${totals.deliveryFee}</span>
                    </div>
                  )}
                  <div className="flex justify-between">
                    <span>Tax:</span>
                    <span>${totals.taxAmount}</span>
                  </div>
                  <Separator className="dark:bg-gray-700" />
                  <div className="flex justify-between text-lg font-bold">
                    <span>Total:</span>
                    <span>${totals.total}</span>
                  </div>
                </div>
              </div>

              {/* Action Buttons */}
              <div className="flex gap-3">
                <Button variant="outline" onClick={() => setShowCart(false)} className="flex-1 dark:border-gray-700 dark:hover:bg-gray-700 dark:text-white">
                  Continue Shopping
                </Button>
                <Button onClick={() => {setShowCart(false); setShowCheckout(true);}} className="flex-1">
                  Checkout
                </Button>
              </div>
            </div>
          )}
        </DialogContent>
      </Dialog>

      {/* Checkout Modal */}
      <Dialog open={showCheckout} onOpenChange={setShowCheckout}>
        <DialogContent className="sm:max-w-2xl max-h-[90vh] overflow-y-auto dark:bg-gray-800 dark:text-white">
          <DialogHeader>
            <DialogTitle>
              {checkoutStep === 'details' && 'Order Details'}
              {checkoutStep === 'payment' && 'Complete Payment'}
              {checkoutStep === 'confirmation' && 'Order Confirmed!'}
            </DialogTitle>
            {checkoutStep === 'confirmation' && (
              <DialogDescription className="dark:text-gray-400">
                You will be redirected to the menu shortly.
              </DialogDescription>
            )}
          </DialogHeader>

          {checkoutStep === 'details' && (
            <div className="space-y-6">
              {/* Customer Information */}
              <Card className="dark:bg-gray-900 dark:border-gray-700 dark:text-white">
                <CardHeader>
                  <CardTitle className="text-lg">Contact Information</CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <Label className="block text-sm font-medium mb-1" htmlFor="customer-name">Name *</Label>
                      <Input
                        id="customer-name"
                        value={customerInfo.name}
                        onChange={(e) => setCustomerInfo({...customerInfo, name: e.target.value})}
                        required
                        className="dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                      />
                    </div>
                    <div>
                      <Label className="block text-sm font-medium mb-1" htmlFor="customer-phone">Phone *</Label>
                      <Input
                        id="customer-phone"
                        type="tel"
                        value={customerInfo.phone}
                        onChange={(e) => setCustomerInfo({...customerInfo, phone: e.target.value})}
                        required
                        className="dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                      />
                    </div>
                  </div>
                  <div>
                    <Label className="block text-sm font-medium mb-1" htmlFor="customer-email">Email (optional)</Label>
                    <Input
                      id="customer-email"
                      type="email"
                      value={customerInfo.email}
                      onChange={(e) => setCustomerInfo({...customerInfo, email: e.target.value})}
                      className="dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                    />
                  </div>
                </CardContent>
              </Card>

              {/* Fulfillment Options */}
              <Card className="dark:bg-gray-900 dark:border-gray-700 dark:text-white">
                <CardHeader>
                  <CardTitle className="text-lg">Order Fulfillment</CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <button
                      type="button"
                      className={`p-4 border rounded-lg text-center transition-colors dark:text-white ${
                        customerInfo.fulfillment_type === "pickup" ? "border-blue-500 bg-blue-50 dark:bg-blue-900 dark:border-blue-700" : "border-gray-200 dark:border-gray-700 dark:bg-gray-800"
                      }`}
                      onClick={() => setCustomerInfo({...customerInfo, fulfillment_type: "pickup"})}
                    >
                      <Store className="w-8 h-8 mx-auto mb-2" />
                      <div className="font-medium">Pickup</div>
                      <div className="text-sm text-gray-500 dark:text-gray-400">Free</div>
                    </button>
                    <button
                      type="button"
                      className={`p-4 border rounded-lg text-center transition-colors dark:text-white ${
                        customerInfo.fulfillment_type === "delivery" ? "border-blue-500 bg-blue-50 dark:bg-blue-900 dark:border-blue-700" : "border-gray-200 dark:border-gray-700 dark:bg-gray-800"
                      }`}
                      onClick={() => setCustomerInfo({...customerInfo, fulfillment_type: "delivery"})}
                    >
                      <Car className="w-8 h-8 mx-auto mb-2" />
                      <div className="font-medium">Delivery</div>
                      <div className="text-sm text-gray-500 dark:text-gray-400">$4.99</div>
                    </button>
                    <button
                      type="button"
                      className={`p-4 border rounded-lg text-center transition-colors dark:text-white ${
                        customerInfo.fulfillment_type === "dine_in" ? "border-blue-500 bg-blue-50 dark:bg-blue-900 dark:border-blue-700" : "border-gray-200 dark:border-gray-700 dark:bg-gray-800"
                      }`}
                      onClick={() => setCustomerInfo({...customerInfo, fulfillment_type: "dine_in"})}
                    >
                      <UtensilsCrossed className="w-8 h-8 mx-auto mb-2" />
                      <div className="font-medium">Dine In</div>
                      <div className="text-sm text-gray-500 dark:text-gray-400">Free</div>
                    </button>
                  </div>

                  {customerInfo.fulfillment_type === "delivery" && (
                    <div>
                      <Label className="block text-sm font-medium mb-1" htmlFor="delivery-address">Delivery Address *</Label>
                      <Textarea
                        id="delivery-address"
                        value={customerInfo.delivery_address}
                        onChange={(e) => setCustomerInfo({...customerInfo, delivery_address: e.target.value})}
                        placeholder="Enter your complete delivery address"
                        required
                        className="dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                      />
                    </div>
                  )}

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <Label className="block text-sm font-medium mb-1" htmlFor="requested-time">Preferred Time (optional)</Label>
                      <Input
                        id="requested-time"
                        type="datetime-local"
                        value={customerInfo.requested_time}
                        onChange={(e) => setCustomerInfo({...customerInfo, requested_time: e.target.value})}
                        min={new Date().toISOString().slice(0, 16)}
                        className="dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                      />
                    </div>
                  </div>

                  <div>
                    <Label className="block text-sm font-medium mb-1" htmlFor="special-instructions">Special Instructions (optional)</Label>
                    <Textarea
                      id="special-instructions"
                      value={customerInfo.special_instructions}
                      onChange={(e) => setCustomerInfo({...customerInfo, special_instructions: e.target.value})}
                      placeholder="Any special requests or dietary restrictions"
                      className="dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                    />
                  </div>
                </CardContent>
              </Card>
              
              {/* Payment Method Selection */}
              <Card className="dark:bg-gray-900 dark:border-gray-700 dark:text-white">
                <CardHeader>
                  <CardTitle className="text-lg">Payment Method</CardTitle>
                </CardHeader>
                <CardContent>
                  <Select
                    value={paymentMethod}
                    onValueChange={setPaymentMethod}
                    disabled={loading}
                  >
                    <SelectTrigger className="w-full dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                      <SelectValue placeholder="Select a payment method" />
                    </SelectTrigger>
                    <SelectContent className="dark:bg-gray-800 dark:border-gray-700 dark:text-white">
                      <SelectItem value="card">
                        <CreditCard className="inline-block w-4 h-4 mr-2" /> Credit/Debit Card
                      </SelectItem>
                      {businessSettings?.online_ordering?.allow_cash_payment !== false && (
                        <SelectItem value="cash">
                          <Receipt className="inline-block w-4 h-4 mr-2" /> Cash on {customerInfo.fulfillment_type === 'delivery' ? 'Delivery' : 'Pickup'}
                        </SelectItem>
                      )}
                      {businessSettings?.solana_pay?.enabled && (
                        <SelectItem value="solana_pay">
                          <Bitcoin className="inline-block w-4 h-4 mr-2" /> Solana Pay
                        </SelectItem>
                      )}
                    </SelectContent>
                  </Select>
                </CardContent>
              </Card>


              {/* Order Summary */}
              <Card className="dark:bg-gray-900 dark:border-gray-700 dark:text-white">
                <CardHeader>
                  <CardTitle className="text-lg">Order Summary</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="space-y-2 text-sm mb-4">
                    {(cart || []).map((item, index) => (
                      <div key={index} className="flex justify-between">
                        <span>{item?.quantity || 0}x {item?.name || 'Item'}</span>
                        <span>${(item?.item_total || 0).toFixed(2)}</span>
                      </div>
                    ))}
                  </div>
                  <Separator className="dark:bg-gray-700" />
                  <div className="space-y-2 text-sm mt-4">
                    <div className="flex justify-between">
                      <span>Subtotal:</span>
                      <span>${totals.subtotal}</span>
                    </div>
                    {parseFloat(totals.deliveryFee) > 0 && (
                      <div className="flex justify-between">
                        <span>Delivery Fee:</span>
                        <span>${totals.deliveryFee}</span>
                      </div>
                    )}
                    <div className="flex justify-between">
                      <span>Tax:</span>
                      <span>${totals.taxAmount}</span>
                    </div>
                    <Separator className="dark:bg-gray-700" />
                    <div className="flex justify-between text-lg font-bold">
                      <span>Total:</span>
                      <span>${totals.total}</span>
                    </div>
                  </div>
                </CardContent>
              </Card>

              {/* Action Buttons */}
              <div className="flex gap-3">
                <Button variant="outline" onClick={() => setShowCheckout(false)} className="flex-1 dark:border-gray-700 dark:hover:bg-gray-700 dark:text-white">
                  Back to Menu
                </Button>
                <Button
                  onClick={initiateOrderProcess}
                  className="flex-1"
                  disabled={
                    !customerInfo.name ||
                    !customerInfo.phone ||
                    (customerInfo.fulfillment_type === "delivery" && !customerInfo.delivery_address) ||
                    loading
                  }
                >
                  {loading ? "Processing..." : "Proceed to Payment"}
                </Button>
              </div>
            </div>
          )}

          {checkoutStep === 'payment' && (
            <div>
              <Tabs defaultValue="card" className="w-full">
                <TabsList className="grid w-full grid-cols-2 dark:bg-gray-700 dark:text-white">
                  <TabsTrigger value="card" className="dark:data-[state=active]:bg-blue-600 dark:data-[state=active]:text-white dark:data-[state=inactive]:text-gray-300 dark:data-[state=inactive]:hover:bg-gray-600"><CreditCard className="w-4 h-4 mr-2"/>Card</TabsTrigger>
                  <TabsTrigger value="crypto" disabled={!businessSettings?.acceptCrypto} className="dark:data-[state=active]:bg-blue-600 dark:data-[state=active]:text-white dark:data-[state=inactive]:text-gray-300 dark:data-[state=inactive]:hover:bg-gray-600"><Bitcoin className="w-4 h-4 mr-2"/>Crypto</TabsTrigger>
                </TabsList>
                <TabsContent value="card" className="pt-4">
                  <Card className="dark:bg-gray-900 dark:border-gray-700 dark:text-white">
                    <CardHeader><CardTitle>Pay with Credit Card</CardTitle></CardHeader>
                    <CardContent className="space-y-4">
                      <div>
                        <Label htmlFor="card-number">Card Number</Label>
                        <Input id="card-number" placeholder="•••• •••• •••• ••••" className="dark:bg-gray-700 dark:border-gray-600 dark:text-white" />
                      </div>
                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <Label htmlFor="card-expiry">Expiry</Label>
                          <Input id="card-expiry" placeholder="MM / YY" className="dark:bg-gray-700 dark:border-gray-600 dark:text-white" />
                        </div>
                        <div>
                          <Label htmlFor="card-cvc">CVC</Label>
                          <Input id="card-cvc" placeholder="•••" className="dark:bg-gray-700 dark:border-gray-600 dark:text-white" />
                        </div>
                      </div>
                      <Button className="w-full" onClick={() => processCardCryptoPayment({ method: 'card' })} disabled={loading}>Pay ${totals.total}</Button>
                      <p className="text-xs text-center text-gray-500 dark:text-gray-400 mt-2">This is a simulated payment form.</p>
                    </CardContent>
                  </Card>
                </TabsContent>
                <TabsContent value="crypto" className="pt-4">
                   <Card className="dark:bg-gray-900 dark:border-gray-700 dark:text-white">
                    <CardHeader><CardTitle>Pay with Crypto</CardTitle></CardHeader>
                    <CardContent className="text-center">
                       <p className="text-sm text-gray-500 dark:text-gray-400 mb-4">Scan the QR code or copy the address for your desired currency.</p>
                       <p className="font-bold text-lg">Total: ${totals.total}</p>
                       {businessSettings?.blockchain ? (
                         <div className="space-y-4 mt-4">
                           {businessSettings.blockchain.btc_address && <div><p className="font-semibold">Bitcoin (BTC)</p><p className="text-xs break-all text-gray-700 dark:text-gray-300">{businessSettings.blockchain.btc_address}</p></div>}
                           {businessSettings.blockchain.eth_address && <div><p className="font-semibold">Ethereum (ETH)</p><p className="text-xs break-all text-gray-700 dark:text-gray-300">{businessSettings.blockchain.eth_address}</p></div>}
                           {businessSettings.blockchain.sol_address && <div><p className="font-semibold">Solana (SOL)</p><p className="text-xs break-all text-gray-700 dark:text-gray-300">{businessSettings.blockchain.sol_address}</p></div>}
                         </div>
                       ) : (
                         <p className="text-sm text-red-500 dark:text-red-400 mt-4">Crypto payments are enabled, but no wallet addresses are configured by the business.</p>
                       )}
                       <Button className="w-full mt-6" onClick={() => processCardCryptoPayment({ method: 'crypto' })} disabled={loading}>I Have Sent The Payment</Button>
                    </CardContent>
                  </Card>
                </TabsContent>
              </Tabs>
               <Button variant="link" onClick={() => setCheckoutStep('details')} className="w-full mt-4 dark:text-blue-400 dark:hover:text-blue-300" disabled={loading}>Back to Details</Button>
            </div>
          )}

          {checkoutStep === 'confirmation' && (
            <div className="text-center py-10">
              <CheckCircle className="w-16 h-16 mx-auto text-green-500 mb-4" />
              <h3 className="text-xl font-semibold">Thank you for your order!</h3>
              <p className="text-gray-500 dark:text-gray-400 mt-2">Your order has been placed successfully. You will receive updates via email/SMS.</p>
            </div>
          )}

        </DialogContent>
      </Dialog>

      {/* Solana Pay Modal (replaces Dialog for Solana Pay) */}
      {showSolanaPayModal && currentOrder && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-xl max-w-md w-full p-6 dark:bg-gray-800 dark:text-white">
            <SolanaPayScreen
              order={currentOrder}
              settings={businessSettings} // Pass businessSettings
              onPaymentComplete={handleSolanaPaymentComplete}
              onPaymentFailed={(error) => {
                console.error("Solana Pay failed:", error);
                alert("Solana Pay transaction failed. Please try again.");
                // Optionally, revert checkout step or allow retry
                setShowSolanaPayModal(false);
                setCurrentOrder(null);
                setCheckoutStep('details');
              }}
            />
            <Button
              variant="outline"
              className="w-full mt-4 dark:border-gray-700 dark:hover:bg-gray-700 dark:text-white"
              onClick={() => {
                setShowSolanaPayModal(false);
                setCurrentOrder(null);
                setCheckoutStep('details'); // Allow user to go back to details
              }}
            >
              Cancel Payment
            </Button>
          </div>
        </div>
      )}


      {/* User Account Modal */}
      {currentUser && (
        <Dialog open={showAccount} onOpenChange={setShowAccount}>
          <DialogContent className="sm:max-w-3xl max-h-[90vh] overflow-y-auto dark:bg-gray-800 dark:text-white">
            <DialogHeader>
              <DialogTitle>My Account</DialogTitle>
              <DialogDescription className="dark:text-gray-400">
                View your order history, favorites, and profile information.
              </DialogDescription>
            </DialogHeader>
            <div className="py-4">
              <div className="flex items-center gap-4 border-b pb-4 mb-4 dark:border-gray-700">
                <div className="w-16 h-16 bg-blue-100 dark:bg-blue-900 rounded-full flex items-center justify-center text-blue-600 dark:text-blue-300 text-2xl font-bold">
                  {currentUser.full_name ? currentUser.full_name.charAt(0).toUpperCase() : 'U'}
                </div>
                <div>
                  <h3 className="text-xl font-semibold">{currentUser.full_name}</h3>
                  <p className="text-muted-foreground dark:text-gray-400">{currentUser.email}</p>
                </div>
              </div>

              <Tabs defaultValue="history">
                <TabsList className="grid w-full grid-cols-2 dark:bg-gray-700">
                  <TabsTrigger value="history" className="dark:data-[state=active]:bg-blue-600 dark:data-[state=active]:text-white dark:data-[state=inactive]:text-gray-300 dark:data-[state=inactive]:hover:bg-gray-600">Order History</TabsTrigger>
                  <TabsTrigger value="favorites" className="dark:data-[state=active]:bg-blue-600 dark:data-[state=active]:text-white dark:data-[state=inactive]:text-gray-300 dark:data-[state=inactive]:hover:bg-gray-600">My Favorites</TabsTrigger>
                </TabsList>
                <TabsContent value="history" className="mt-4">
                  <div className="space-y-4">
                    {(pastOrders || []).length > 0 ? (
                      (pastOrders || []).map(order => (
                        <Card key={order.id} className="dark:bg-gray-900 dark:border-gray-700 dark:text-white">
                          <CardContent className="p-4 flex justify-between items-center">
                            <div>
                              <p className="font-semibold">Order {order.order_number}</p>
                              <p className="text-sm text-muted-foreground dark:text-gray-400">{new Date(order.created_date).toLocaleString()}</p>
                            </div>
                            <div className="text-right">
                              <p className="font-bold">${order.total.toFixed(2)}</p>
                              <Badge variant="secondary" className="capitalize mt-1 dark:bg-gray-700 dark:text-white">{order.status}</Badge>
                            </div>
                          </CardContent>
                        </Card>
                      ))
                    ) : (
                      <p className="text-center text-muted-foreground py-8 dark:text-gray-400">No past orders found.</p>
                    )}
                  </div>
                </TabsContent>
                <TabsContent value="favorites" className="mt-4">
                  {(favoriteProducts || []).length > 0 ? (
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                      {(favoriteProducts || []).map(product => (
                        <ProductCard
                          key={product.id}
                          product={product}
                          // This ProductCard uses its own onAddToCart logic, consistent with the original handleAddToCartRequest
                          onAddToCart={(p) => {
                            if (p.modifiers && p.modifiers.length > 0) {
                                setSelectedProductForModifiers(p);
                            } else {
                                addToCart(p);
                            }
                          }}
                          onToggleFavorite={handleToggleFavorite}
                          isFavorite={true}
                        />
                      ))}
                    </div>
                  ) : (
                    <p className="text-center text-muted-foreground py-8 dark:text-gray-400">You haven't favorited any items yet.</p>
                  )}
                </TabsContent>
              </Tabs>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setShowAccount(false)} className="dark:border-gray-700 dark:hover:bg-gray-700 dark:text-white">Close</Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
    </div>
  );
}
